# 3.14-Collision Finding and Element Distinctness

Here is the entry for the twenty-seventh algorithm. This family of problems deals with the fundamental task of finding duplicates in data, a core component of many algorithms and cryptographic attacks.

***

### 27. Collision Finding and Element Distinctness

This family of related problems deals with finding "collisions"‚Äîpairs of different inputs that produce the same output from a function. The classical solution is famously related to the **Birthday Problem**, while the quantum solutions, based on Grover's search and especially on quantum walks, offer significant polynomial speedups. These algorithms are crucial in cryptography and as subroutines for more complex problems.

* **Complexity**: **Polynomial Speedup**
    * **Collision Finding (2-to-1 function)**: Quantum: $O(N^{1/3})$ queries vs. Classical: $O(\sqrt{N})$.
    * **Element Distinctness (general function)**: Quantum: $O(N^{2/3})$ queries vs. Classical: $O(N)$.
    * **Claw Finding (two functions)**: Quantum: $O(N^{2/3})$ queries vs. Classical: $O(N)$.

* **Implementation Libraries**: These are foundational theoretical algorithms and are **not implemented in standard quantum libraries**.

***

### **Detailed Theory üß†**

The various problems in this family have different constraints, leading to different optimal algorithms and complexities.

**Part 1: The Intuition - The Birthday Problem**

The classical approach to finding collisions is best understood through the Birthday Problem: "How many people do you need in a room for it to be likely that two share a birthday?" The answer is surprisingly small: just 23.

This illustrates that to find a collision in a set of $N$ possible outcomes (e.g., 365 birthdays), you don't need to check $N$ items. You only need to check about $\sqrt{N}$ items before a collision becomes likely. This gives the **$O(\sqrt{N})$ classical randomized complexity** for finding a collision.

**Part 2: The Collision Problem**

* **The Setup**: We are given an oracle for a function $f$ that is promised to be **2-to-1**, meaning every output value corresponds to exactly two input values.
* **The Goal**: Find a pair of distinct inputs $x, y$ such that $f(x) = f(y)$.
* **The Quantum Algorithm (BHT)**: The quantum algorithm by Brassard, H√∏yer, and Tapp uses a clever hybrid approach. It optimally balances a classical search with a quantum search (Grover's algorithm) to achieve a complexity of **$O(N^{1/3})$**. This is a significant polynomial improvement over the classical $O(\sqrt{N})$ bound.



**Part 3: The Element Distinctness Problem**

This is the more general and difficult version of the problem.

* **The Setup**: We are given an oracle for an arbitrary function $f$. We are no longer promised that it is 2-to-1.
* **The Goal**: Determine if there exists *any* pair of distinct inputs $x, y$ such that $f(x) = f(y)$.
* **Classical Approach**: In the worst case, you might have to query every single input to see if you've seen its output before. This takes $O(N)$ time.
* **The Quantum Algorithm (Ambainis's Quantum Walk)**: This problem required a major algorithmic breakthrough. The optimal quantum algorithm, developed by Andris Ambainis, is **not** based on Grover's search but on a sophisticated **quantum walk** on a specially designed graph.
    1.  The algorithm keeps track of a growing subset of queried (input, output) pairs in a superposition.
    2.  The quantum walk evolves this superposition. The "walker" moves on a graph where vertices represent the subsets of data checked so far.
    3.  A "marked" vertex corresponds to finding a collision within the stored data.
    4.  The quantum walk is engineered so that it finds a marked vertex much faster than a classical search could. Its ability to explore the graph of possibilities in parallel leads to the **$O(N^{2/3})$** query complexity, which is provably optimal.

**Part 4: Related Problems**

* **Claw Finding**: Given two functions, $f$ and $g$, find a "claw"‚Äîa pair of inputs $(x, y)$ such that $f(x) = g(y)$. This can also be solved in $O(N^{2/3})$ time using the quantum walk approach.
* **k-Distinctness**: This asks if there is any set of $k$ distinct inputs that all map to the same output. The quantum walk can be generalized to solve this in $O(N^{k/(k+1)})$ time.

---

### **Significance and Use Cases üèõÔ∏è**

* **Cryptanalysis of Hash Functions**: The security of cryptographic hash functions relies on **collision resistance**. Finding two different messages that hash to the same value would break the hash function. The BHT algorithm sets the theoretical security limit for any hash function against a quantum computer. For an $n$-bit hash function (with $N=2^n$ outputs), the quantum attack complexity is $O(2^{n/3})$, compared to the classical "birthday attack" of $O(2^{n/2})$. This means future cryptographic standards may require larger hash sizes to maintain security in a quantum world.

* **A Powerful Algorithmic Subroutine**: The element distinctness algorithm is a core primitive used inside other, more complex quantum algorithms. We have already seen it used to provide speedups for the **Subset-Sum problem** and for testing **Graph Properties** in the adjacency list model.

* **Showcasing the Power of Quantum Walks**: This family of algorithms, and element distinctness in particular, is the canonical example of the power of quantum walks for search. It proved that for certain structured search problems, quantum walks are fundamentally more powerful than Grover's algorithm, establishing them as a distinct and vital tool in quantum algorithm design.

---

### **References**

* [18] Brassard, G., H√∏yer, P., & Tapp, A. (1998). *Quantum counting*. In Proceedings of 25th International Colloquium on Automata, Languages, and Programming.
* [7] Ambainis, A. (2007). *Quantum walk algorithm for element distinctness*. SIAM Journal on Computing, 37(1), 210-239.
* Belovs, A. (2012). *Span programs for functions with constant-sized 1-certificates*. In Proceedings of the 44th symposium on Theory of Computing. (This paper and related works provide the tight bounds for k-distinctness using the span-program formalism).


